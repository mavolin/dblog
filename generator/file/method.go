package file

import (
	"fmt"
	"go/types"
)

type (
	Method struct {
		// Name is the name of the file.
		Name    string
		Params  []Param
		Returns []Return
	}

	Param struct {
		// Name is the name of the parameter.
		//
		// If the parameter was not named in the interface definition, Name
		// will be generated by dblog.
		Name string
		// GeneratedName indicates whether Name was generated by dblog.
		GeneratedName bool
		// Type is the type of the parameter.
		Type Type
		// Variadic indicates whether the parameter is variadic.
		//
		// This can only be true for the last parameter.
		//
		// If true, Type will be of type Array.
		Variadic bool
	}

	Return struct {
		// Name is the name of the return value and is also used as the name of
		// the variable that holds this return value.
		//
		// If the return value was not named in the interface definition, Name
		// will be generated by dblog.
		Name string
		// GeneratedName indicates whether Name was generated by dblog.
		GeneratedName bool
		// Type is the type of the return value.
		Type Type
	}
)

func NewMethod(f *types.Func, im *ImportManager) (*Method, error) {
	var m Method
	m.Name = f.Name()

	// Func's doc says Type() always returns a *Signature
	sig := f.Type().(*types.Signature)

	if params := sig.Params(); params != nil {
		m.Params = make([]Param, params.Len())
		for i := 0; i < params.Len(); i++ {
			param := params.At(i)

			name := fmt.Sprint("param", i+1)
			if param.Name() != "" {
				name = param.Name()
			}

			p, err := NewParam(name, param, im)
			if err != nil {
				return nil, err
			}

			if i == params.Len()-1 {
				p.Variadic = sig.Variadic()
			}

			m.Params[i] = *p
		}
	}

	if results := sig.Results(); results != nil {
		m.Returns = make([]Return, results.Len())
		for i := 0; i < results.Len(); i++ {
			result := results.At(i)

			name := fmt.Sprint("ret", i+1)
			if result.Name() != "" {
				name = result.Name()
			}

			r, err := NewReturn(name, result, im)
			if err != nil {
				return nil, err
			}

			m.Returns[i] = *r
		}
	}

	return &m, nil
}

func NewParam(name string, v *types.Var, im *ImportManager) (*Param, error) {
	typ, err := NewType(v.Type(), im)
	if err != nil {
		return nil, err
	}

	return &Param{Name: name, Type: typ}, nil
}

func NewReturn(name string, v *types.Var, im *ImportManager) (*Return, error) {
	typ, err := NewType(v.Type(), im)
	if err != nil {
		return nil, err
	}

	return &Return{Name: name, Type: typ}, err
}
