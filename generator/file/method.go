package file

import (
	"go/types"
)

type (
	Method struct {
		// Name is the name of the file.
		Name    string
		Params  []Param
		Returns []Return
	}

	Param struct {
		// Name is the name of the parameter.
		//
		// If the parameter was not named in the interface definition, Name
		// will be generated by dblog.
		Name string
		// GeneratedName indicates whether Name was generated by dblog.
		GeneratedName bool
		// Type is the type of the parameter.
		Type Type
		// Variadic indicates whether the parameter is variadic.
		//
		// This can only be true for the last parameter.
		Variadic bool
	}

	Return struct {
		// Name is the name of the return value and is also used as the name of
		// the variable that holds this return value.
		//
		// If the return value was not named in the interface definition, Name
		// will be generated by dblog.
		Name string
		// GeneratedName indicates whether Name was generated by dblog.
		GeneratedName bool
		// Type is the type of the return value.
		Type Type
	}
)

func NewMethod(f *types.Func, im *ImportManager) (*Method, error) {
	var m Method
	m.Name = f.Name()

	// Func's docs say Type() always returns a *Signature
	sig := f.Type().(*types.Signature)

	ng := make(nameGenerator)

	if params := sig.Params(); params != nil {
		m.Params = make([]Param, params.Len())
		for i := 0; i < params.Len(); i++ {
			param := params.At(i)
			p, err := NewParam(param, ng, im)
			if err != nil {
				return nil, err
			}

			if i == params.Len()-1 {
				p.Variadic = sig.Variadic()
			}

			m.Params[i] = *p
		}
	}

	if results := sig.Results(); results != nil {
		m.Returns = make([]Return, results.Len())
		for i := 0; i < results.Len(); i++ {
			result := results.At(i)
			r, err := NewReturn(result, ng, im)
			if err != nil {
				return nil, err
			}

			m.Returns[i] = *r
		}
	}

	return &m, nil
}

func NewParam(v *types.Var, ng nameGenerator, im *ImportManager) (_ *Param, err error) {
	var p Param

	if v.Name() == "" {
		p.Name = ng.generate("param")
		p.GeneratedName = true
	} else {
		p.Name = v.Name()
	}

	p.Type, err = NewType(v.Type(), im)
	if err != nil {
		return nil, err
	}

	return &p, nil
}

func NewReturn(v *types.Var, ng nameGenerator, im *ImportManager) (_ *Return, err error) {
	var r Return

	r.Type, err = NewType(v.Type(), im)
	if err != nil {
		return nil, err
	}

	if v.Name() == "" {
		r.Name = ng.generate("ret")
		r.GeneratedName = true
	} else {
		r.Name = v.Name()
	}

	return &r, err
}
